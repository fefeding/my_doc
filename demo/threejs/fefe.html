<!doctype html>
<html>
	<head>
	<meta content="text/html; charset=UTF-8" http-equiv="content-type" />
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<style>
		html,body{
			margin:0;
			padding: 0;
		}
		canvas {
			cursor: pointer;
		}
		#mycanvas_container{
			overflow: hidden;		
		}		
	</style>
	</head>
	<body>
		
	</body>
    <!--<script type="module" src="node_modules/three/build/three.min.js"></script>-->
    <script type="module">
        /// <reference path="./node_modules/@types/three/index.d.ts" />
        import * as THREE from './node_modules/three/src/Three.js';
        import { GLTFLoader } from './lib/threejs/jsm/loaders/GLTFLoader.js';
       
        // init
        let width = window.innerWidth, height = window.innerHeight;
        const camera = new THREE.PerspectiveCamera( 50, width / height, 0.1, 1000 );
        camera.position.z = 50; 
        camera.position.x = 0;
        camera.position.y = 0;

        camera.lookAt(0, -10);

        const backgroundColor = 0xf1f1f1;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(backgroundColor);
        //雾化的模糊效果
        //scene.fog = new THREE.Fog(backgroundColor, 60, 100);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61);
        hemiLight.position.set(0, 50, 0);
        // Add hemisphere light to scene
        scene.add(hemiLight);

        let d = 8.25;
        let dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
        dirLight.position.set(-8, 12, 8);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 1500;
        dirLight.shadow.camera.left = d * -1;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = d * -1;
        // Add directional Light to scene
        scene.add(dirLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100, 500, 500);
        const floorMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color("#ccc"),
            wireframe: true,
            shininess: 0,
        });

        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -0.5 * Math.PI; // This is 90 degrees by the way
        floor.receiveShadow = true;
        floor.position.y = -11;
        scene.add(floor);

        const geometry = new THREE.BoxGeometry( 1, 1, 1 );
        const material = new THREE.MeshNormalMaterial();

        const mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = -10;
        mesh.position.y = 5;
        scene.add( mesh );

        const renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( width, height );
        // 人物对象能投射阴影
        renderer.shadowMap.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);

        renderer.setAnimationLoop( animation );
        document.body.appendChild( renderer.domElement );

        let stacy_txt = new THREE.TextureLoader().load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/1376484/stacy.jpg');
        stacy_txt.flipY = false; // we flip the texture so that its the right way up
        const stacy_mtl = new THREE.MeshPhongMaterial({
            map: stacy_txt,
            color: 0xffffff,
            skinning: true
        });

        // 加载人物模型
        const loader = new GLTFLoader();
        let myModel = null;
        loader.load('model/fefe.glb', (gltf) => {
            myModel = gltf.scene;
            const fileAnis = gltf.animations;
            console.log(fileAnis);

            

            // 使用模型的 traverse 方法遍历所有网格（mesh）以启用投射和接收阴影的能力。该操作需要在 scene.add(model) 前完成。
            myModel.traverse(o => {
                if (o.isBone) {
                    console.log(o.name);
                }
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                    //o.material = stacy_mtl;
                }
            });
            myModel.scale.set(7, 7, 7);
            myModel.position.y = -11;

            scene.add(myModel);
        }, undefined, (err) => {
            console.error(err);
        });

       /* window.onresize = (e) => {
            width = window.innerWidth, height = window.innerHeight;
            camera.aspect = width / height;
            renderer.setSize( width, height, false );
        }*/
        // 检查是否需要更新大小
        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            let width = window.innerWidth;
            let height = window.innerHeight;
            let canvasPixelWidth = canvas.width / window.devicePixelRatio;
            let canvasPixelHeight = canvas.height / window.devicePixelRatio;

            const needResize =
                canvasPixelWidth !== width || canvasPixelHeight !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

        // animation

        function animation( time ) {
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }
            mesh.rotation.x = time / 5000;
            mesh.rotation.y = time / 2000;

            if(myModel) {
                //myModel.rotation.x = mesh.rotation.x;
                myModel.rotation.y = mesh.rotation.y;
            }

            
            renderer.render( scene, camera );

        }
	</script>
</html>